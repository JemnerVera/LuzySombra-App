Â 
Responsable
Cargo
Fecha
AUTOR
RaÃºl GarcÃ­a Barrientos
Administrador de Base
de Datos
03/10/2025
REVISADO
POR
Christian Villaverde / Daniel
Carhuamaca
Team Desarrollo
Â 
APROBADO
POR
Patricio Sandoval
Gerente TI
Â 
Fecha
Autor
VersiÃ³n
Referencia de Cambio
03/10/2025
RaÃºl GarcÃ­a
1.0
CreaciÃ³n del documento
Â 
Â 
Â 
Â 
PolÃ­tica de EstÃ¡ndares de CodificaciÃ³n
de Bases de Datos
 
Control del Documento
 
Objetivo
 
El presente documento tiene como objetivo establecer y formalizar un lenguaje (cÃ³digo y 
estructura) comÃºn para la implementaciÃ³n de objetos de base de datos en Migiva y sus 
empresas, permitiendo un fÃ¡cil entendimiento y mantenimiento en el desarrollo de los proyectos.
Alcance
 
El alcance del documento involucra a todos aquellos proyectos y Ã¡reas que tengan que ver con el 
desarrollo y mantenimiento de aplicaciones de Base de Datos ya sea que estÃ©n en producciÃ³n o 
en fase de proyectos.
Documentos Asociados
 
Â 
Definiciones
 
BD: Base de Datos.
DBA: Administrador de base de datos.
TI: Ãrea de TecnologÃ­as de InformaciÃ³n.
ANSI: American National Standards Institute.
DBMS: Data Base Management System, Sistema gestor de bases de datos.
DCL: Data Control Language, Lenguaje de Control de Datos.
DDL: Data Definition Language, Lenguaje de DefiniciÃ³n de Datos.

DML: Data Modification Language. Lenguaje de ModificaciÃ³n de Datos.
ER: Entidad RelaciÃ³n.
FK: Foreign Key. Llave forÃ¡nea.
PK: Primary Key. Llave primaria.
SGBD: VÃ©ase DBMS.
SO: Sistema Operativo.
SQL: Structured Query Language. Lenguaje Estructurado de Consultas.
Nomenclatura
 
Consideraciones Generales
 
1. Los nombres de los objetos deben ser lo mÃ¡s corto posible, fÃ¡ciles de leer, y lo mÃ¡s 
descriptivo posible, evitando tÃ©rminos ambiguos o que se prestan a distintas 
interpretaciones.
2. Los nombres deben incluir solo caracteres del alfabeto espaÃ±ol excepto vocales con acento, 
eÃ±es y diÃ©resis, y no deben utilizarse caracteres especiales (â€˜#â€™, â€˜/â€™, â€˜;â€™, â€˜%â€™, â€˜+â€™, etc) ni espacios, el 
Ãºnico carÃ¡cter especial que se permitirÃ¡ y exclusivamente en los casos que se especificarÃ¡n 
posteriormente serÃ¡ el underscore â€˜_â€™ ; el uso de nÃºmeros debe evitarse de ser posible.
3. Se usarÃ¡ el CamelCase como estilo de escritura. El LowerCamelCase para diferentes 
nombres de los objetos de las bases de datos.
4. Se usarÃ¡ el lenguaje espaÃ±ol como el lenguaje para los diferentes nombres de los objetos.
Nota: Existen nombres en inglÃ©s, se debe respetar los nombres origen de los campos.
Abreviaturas Recomendadas
 
A continuaciÃ³n se muestra una lista con las abreviaturas que pueden ser usadas como prefijos 
para dar nombre a un objeto. AquÃ­ algunos ejemplos:

DescripciÃ³n
NemÃ³nico
AGRICOLA
AGRI
ARANDANO
ARA
CALIDAD
CAL
CLIENTE
CLI
COMERCIAL
COM
CONCEPTOS
CON
CONTROL
CTR
COSECHA
COS
DEFECTO
DEF
DESHIDRATACION
DHID
DETALLE
DET
DOCUMENTO
DOCU
EMBARQUE
EMB
ENFERMEDAD
ENF
EVALUACION
EVAL
FACTURA
FT
FECHA
FEC
FORMULARIO
FORM
GASIFICADO
GAS
GRUPO
GRP
INDIVIDUAL
INDV
INDUSTRIAL
INDU
INSPECCION
INSP
INSTRUCTIVO
INST
MADUREZ
MDZ
MATERIAL
MAT
MIGRACION
MIG
MOVIMIENTO
MOV
NOTA CREDITO
NC
NOTA DEBITO
ND

DescripciÃ³n
NemÃ³nico
PACKING
PKG
PAGO
PAG
PARAMETRO
PARAM
PLANTILLA
PLA
PRECOSECHA
PCOS
PROCESO
PROC
PRODUCCION
PROD
PROGRAMACION
PROG
PROYECCION
PROY
REPORTE
REP
SEGUIMIENTO
SEG
SOLICITUD
SOL
STOCK
STK
SUPERVISION
SPV
TUNELIZADO
TUN
Â 
Â 
Usuarios
 
Usuario Owner (Propietario)
 
Se definirÃ¡n con la nomenclatura â€œUCOWN_â€ seguido del nombre del servicio, un nombre 
representativo o abreviatura.
UCOWN_ [Nombre del Servicio] => UCOWN_SISPACKING
Usuario de Servicio (Sistema, AplicaciÃ³n o ConexiÃ³n)
 
Se definirÃ¡n con la primera letra â€œUCSERâ€ seguido del nombre del servicio, un nombre 
representativo o abreviatura.
UCSER_ [Nombre del Servicio] => UCSER_SISPACKING
Usuario de Soporte
 
Se definirÃ¡n con el prefijo "UCSOP" seguido del nombre del personal de TI
UCSOP_ [Inicial nombre del personal] [Apellido del personal] => UCSOP_RGARCIA 

Usuario de Responsabilidad
 
Se definirÃ¡n con el prefijo "UCRES" seguido del nombre del personal de TI
UCRES_[Inicial nombre del personal] [Apellido del personal] => UCRES_RGARCIA 
Usuario de Link Server
 
El prefijo a usar para este usuario es UCLNK_
UCLNK_[Nombre de BD o SCHEMA] _ [Nombre de Instancia]  =>UCLNK_PACKING_CAL
Usuarios de Uso Temporal
 
ContendrÃ¡n el prefijo "TMP" en el nombre del usuario segÃºn los siguientes casos:
Usuarios temporales para responsabilidad. 
UCRES_[Inicial nombre del personal] [Apellido del personal] _TMP => UCRES_RGARCIA_TMP 
Usuarios temporales de servicio asignado a una persona, 
UCSER_[Inicial nombre del personal] [Apellido del personal] _TMP => UCSER_RGARCIA_TMP
Para otros casos: 
UCTMP_[Inicial nombre del personal] [Apellido del personal] _ [Nombre del servicio] => 
UCTMP_RGARCIA_VENTURA
Esquema
 
Los nombres de los esquemas irÃ¡n en base al Ã¡rea, proceso, mÃ³dulo, sistema que especifique el 
alcance de la necesidad. Los siguientes son esquemas de base de datos:

Esquema
agroamigo
agrocom
archivo
asist
audit
calidadAgricola
Comercial
commerce
cultivador
EMBARQUE
erp
evalAgri
grower
history
HumanResource
Integraciones
interp
lora
Maestra
mast
package
packing
phytosanitary
planta
ppp
proper
pwbi
quality
qualitycrop
recursoHumano

Esquema
report
sales
shipping
util
wow
Â 
Tablas
 
Las tablas segÃºn sea el caso deben se definirÃ¡n de la siguiente manera:
Comienzan con el nombre de la entidad 
Luego la DescripciÃ³n corresponde a una descripciÃ³n de la entidad y/o uso de la tabla.
Comunes
 
 [nombreDescripciÃ³n] => inspeccionCosechaUvaSupervisor
Externas
 
[nombreDescripciÃ³n]_ext => inspeccionCosechaUvaSupervisor_ext
Temporales (de paso)
 
Que se usan de paso para un determinado proceso y comunmente se truncan.
[nombreDescripciÃ³n]_tmp => inspeccionCosechaUvaSupervisor_tmp
Temporales (de sesiÃ³n)
 
#tempXXX_[nombreDescripcion] => #temp001_inspeccionCosechaUvaSupervisor
Primary Key
 
PK_[nombreTabla] => PK_inspeccionCosechaUvaSupervisor
(Se debe especificar el nombre al crearlo, no esta permitido los nombres autogenerados)
Constraints
 
Los constraint se definirÃ¡n de la siguiente manera:
Foreign Key
 
FK _ [nombreTabla]_ [nombreTablaReferencia] _XX => 
FK_inspeccionCosechaUvaSupervisor_packing_01
Donde:
nombreTabla es el nombre de la tabla actual o tabla hija
nombreTablaReferenciada es el nombre de la tabla referenciada o padre 
XX es el correlativo.

Unique Constraint
 
UQ_ [nombreTabla]_ [nombreColumna] _XX => UQ_inspeccionCosechaUvaSupervisor_dni_01
Donde:
nombreTabla es el nombre de la tabla actual
nombreColumnas es el nombre de la o las columnas separadas por "_" 
XX es el correlativo.
(Se debe especificar el nombre al crearlo, no esta permitido los nombres autogenerados)
Check Constraint
 
CK_ [nombreTabla]_ [regla] _XX => CK_inspeccionCosechaUvaSupervisor_precioMayor100_01
Donde:
nombreTabla es el nombre de la tabla actual
regla es la descripciÃ³n de la regla de negocio breve y concisa 
XX es el correlativo.
(Se debe especificar el nombre al crearlo, no esta permitido los nombres autogenerados)
Default Constraint
 
DF_ [nombreTabla]_ [nombreColumna] _XX => DF_inspeccionCosechaUvaSupervisor_estadoID_01
Donde:
nombreTabla es el nombre de la tabla actual
nombreColumna es el nombre de la o las columnas separadas por "_" 
XX es el correlativo.
(Se debe especificar el nombre al crearlo, no esta permitido los nombres autogenerados)
Ãndices
 
Los Ã­ndices se definirÃ¡n de la siguiente manera:
IDX_ [nombreTabla]_[nombreColumnas] _XXX => 
IDX_inspeccionCosechaUvaSupervisor_usuarioID_fecha_001
El IDX es el prefijo
nombreTabla es el nombre de la tabla o descripciÃ³n del Ã­ndice.
nombreColumnas es el nombre de la o las columnas separadas por "_"
XXX es el correlativo segÃºn el nÃºmero de Ã­ndices.
Nota: No esta permitido la creaciÃ³n de Ãndices con nombres autogenerados estos siempre tienen 
que tener un nombre.
Triggers
 
Los triggers se definirÃ¡n de la siguiente manera:
trg_ [NNNN] _ [Tipo de Trigger] _[DML] => trg_inspeccionCosechaUvaSupervisor_AF_IU
Donde:
NNNN es el nombre de la Tabla

Tipo
Abreviatura
AFTER
AF
INSTEAD OF
IO
Tipo de Trigger es la abreviatura del tipo de disparador que se lanza y puede ser uno de los 
siguientes:
Orden DML
Abreviatura
INSERT
I
UPDATE
U
DELETE
D
DML es la abreviatura que se define por el tipo de orden DML que provoca la activaciÃ³n del 
disparador
En el ejemplo trg_inspeccionCosechaUvaSupervisor_AF_IU se indica que corresponde a un trigger 
de la tabla inspeccionCosechaUvaSupervisor que se ejecutarÃ¡ despuÃ©s de la acciÃ³n insert o 
update de la tabla.
Vistas
 
Las vistas se definirÃ¡n de la siguiente manera segÃºn su naturaleza:
vwc_Calidad_ResumenMensualInspecciones.
vwp_ [MMMM] _[NNNN] => Para vistas primarias, es decir se componen de una sola tabla.
vwc_ [MMMM] _[NNNN] => Para vistas compuestas, es decir se componen de mÃ¡s de una tabla.
Donde:
MMMM se refiere al mÃ³dulo, Ã¡rea, sistema para el cual fue creada la vista
NNNN en el caso de la vista primaria es el nombre de la tabla que compone la vista y en el 
caso de la vistas compuestas es el nombre que se le da.
Procedimientos almacenados
 
Los procedimientos almacenados se definirÃ¡n de la siguiente manera:
usp _ [PREFIJO] _ [Descripcion] => usp_calidadAgricola_calculoInspeccionCosecha
Donde:
PREFIJO corresponde a la abreviatura definida para el servicio.
DescripciÃ³n corresponde al nombre del procedimiento segÃºn la acciÃ³n(o servicio) que va a 
realizar.
Para los procedimientos almacenados de un CRUD de una tabla se realizarÃ¡ de la siguiente 
manera:
usp_calidadAgricola_inspeccionCosechaUvaSupervisor_ins
usp _ [PREFIJO] _ [nombreTabla] _ins => Para el insert
usp _ [PREFIJO] _ [nombreTabla] _upd => Para el update

usp _ [PREFIJO] _ [nombreTabla] _del => Para el delete (cambio de estado)
usp _ [PREFIJO] _ [nombreTabla] _sel => Para el select de la tabla
Funciones
 
Las funciones se definirÃ¡n de la siguiente manera
Funcion con valor Escalar
 
ufn _ [PREFIJO] _ [Descripcion] => ufn_calidadAgricola_obtenerFecha
Funcion con Valor de Tabla
 
uft _ [PREFIJO] _ [Descripcion] => uft_calidadAgricola_obtenerResumenRendimiento
Donde:
PREFIJO corresponde a la abreviatura definida para el servicio.
DescripciÃ³n corresponde al nombre de la funciÃ³n segÃºn la acciÃ³n(o servicio) que va a realizar.
Secuencias
 
Las secuencias se definirÃ¡n de la siguiente manera:
Si la secuencia es usada por alguna tabla.
seq_ [NNNN] _XX
Si la secuencia no son usadas por las tablas
seqG_ [NNNN] _XX
Donde:
NNNN es el nombre de la tabla a la que hace referencia o servicio.
XX es un correlativo.
Types
 
Type Tabla
 
uTyp _ [PREFIJO] _ [Descripcion]
Los objetos tipo tabla se definirÃ¡n de la siguiente manera
PREFIJO corresponde a la abreviatura definida para el servicio.
DescripciÃ³n corresponde al nombre de la funciÃ³n segÃºn la acciÃ³n(o servicio) que va a realizar.
Estructura de Consultas
 
1. Las consultas (SELECT) deben ser legibles a la vista para una mejor revisiÃ³n y lectura de esta, 
un ejemplo serÃ­a de la siguiente manera:
SELECT
 Â   c.CustomerName,
 Â   c.Email,
 Â   c.City,
 Â  Â COUNT(o.OrderID) AS NumeroPedidos
FROM
 Â   Customers c

2. Evitar el uso del SELECT * en lo posible, nombrar las columnas que necesitas y/o se utilizan 
en la consulta, esto mejora la legibilidad, la eficiencia y la robustez de la consulta.
3. Uso del WITH (NOLOCK) cuando el rendimiento es mÃ¡s importante que la precisiÃ³n de los 
datos, como por ejemplo en reportes o anÃ¡lisis, evitando que las lecturas bloqueen 
operaciones de escritura. Recordar que si se requiere precisiÃ³n de los datos no es 
recomendable su uso ya que realiza "Lectura sucia".
4. No usar funciones en los campos de filtro de una consulta (WHERE), ya que esto  impiden un 
uso eficiente de los Ã­ndices.
DiseÃ±o de Objetos
 
Tabla
 
Tipos de datos
 
Los tipos de datos deben ser los mas acordes al dato que se va a guardar en la base de datos, 
usar lo siguiente como base:
Fechas cortas: date
Fecha y hora: datetime
Horas: time
Texto corto: varchar(n)
Texto largo: varchar(max)
NÃºmericos: decimal(18,4)
Flag: bit
    INNER JOIN Ordenes o ON o.clienteID = c.clienteID
WHERE
 Â   c.Country = 'Mexico'
 Â  Â AND c.IsActive = 1
GROUP BY
 Â   c.CustomerName,
 Â   c.Email,
 Â   c.City
HAVING
 Â  Â COUNT(o.OrderID) > 5
ORDER BY
 Â   NumeroPedidos DESC;
-- NO USAR
SELECT c.* FROM Customers c
-- USAR
SELECT
 Â   c.CustomerName,
 Â   c.Email,
 Â   c.City
FROM
 Â   Customers c

Primary Key
 
El Primary Key a excepciÃ³n de otra casuÃ­stica, debe ser INT con IDENTITY(1,1)
Foreing Key
 
Todas las tablas deben tener y estar referenciadas con su tabla padre para la integridad 
referencial respectiva.
Columnas NOT NULL
 
Las columnas deben tener NOT NULL definido, en caso sea NULL debe estar justificado.
CreaciÃ³n del CHECK Contraint
 
En las tablas debe estar definido los CHECK CONSTRAINT segÃºn la regla de negocio y deben ser 
nombrados segÃºn la nomenclatura.
CreaciÃ³n de Ãndices
 
En las tablas debe estar definido los ÃNIDCES segÃºn las bÃºsquedas y/o consultas que realizan las 
operaciones, y deben ser nombrados segÃºn la nomenclatura.
Procedimientos Almacenados y Funciones
 
ParÃ¡metros
 
Los parÃ¡metros deben poder identificarse si son de entrada (IN), de salida (OUT) o ambos a la vez 
(INOUT) se crearÃ¡n de la siguiente manera:
pIn_   para parÃ¡metros de entrada
pOu_  para parÃ¡metros de salida
pIO_  para parÃ¡metros de entrada y salida
Variables
 
Las variables deben poder identificarse del mismo modo que los parÃ¡metros. Para ello solo 
usaremos v como inicio de la variable. Ejemplo: vPackingNuevo
Try Catch
 
Uso del TRY - CATCH para el manejo de errores y gestionar y mitigar fallos durante la ejecuciÃ³n de 
cÃ³digo Transact-SQL
Throw
 
Para la generaciÃ³n de errores personalizados debe usarse THROW
Return
 
Uso con cuidado del RETURN, usar de preferencia y con mayor control los antes mencionados 
(Try-Catch y Throw)

Uso de instrucciones SET
 
Se usarÃ¡n como parte del procedimiento almacenado las siguientes instrucciones SET:
DocumentaciÃ³n
 
Tablas
 
1. Para la creaciÃ³n de tablas, estas deben tener sus respectivos comentarios tanto a nivel de 
tabla como de a nivel de columna, esto orientado a tener el diccionario de datos dentro de la 
misma Base de Datos
2. Las tablas deben tener los siguientes columnas y/o campos de auditorÃ­a
Procedimientos Almacenados, Triggers y Funciones
 
1. Todos los procedimientos almacenados, triggers y funciones deben contener el siguiente 
encabezado y en la parte revisiones se debe iterar segÃºn los cambios realizados:
SET NOCOUNT ON; -- Evitar que el servidor envie mensajes de filas afectadas
SET ARITHABORT ON; -- Interrumpe la ejecuciÃ³n por errores aritmÃ©ticos
SET ANSI_NULLS ON; -- Evaluar las comparaciones de valor NULL segÃºn estandar de 
SQL
SET XACT_ABORT ON; -- Interrumpe la ejecuciÃ³n si una sentencia T-SQL genera un 
error
-- Tablas
EXEC sys.sp_addextendedproperty @name = N'MS_TablaDescription', Â  @value = 
N'[Descripcion de la tabla]',  @level0type = N'SCHEMA', @level0name = 
'[schema_name]',  @level1type = N'TABLE',  @level1name = '[table_name]'; Â 
-- Columnas de las tablas
EXEC sp_addextendedproperty  @name = N'MS_Col1Desc',  @value = '[Descripcion de 
la columna 1]',  @level0type = N'Schema', @level0name = '[schema_name]',  
@level1type = N'Table',  @level1name = '[table_name]',  @level2type = N'Column', 
@level2name = '[column1_name]'; Â 
EXEC sp_addextendedproperty  @name = N'MS_Col2Desc',  @value = '[Descripcion de 
la columna 2]',  @level0type = N'Schema', @level0name = '[schema_name]',  
@level1type = N'Table',  @level1name = '[table_name]',  @level2type = N'Column', 
@level2name = '[column2_name]';
EXEC sp_addextendedproperty  @name = N'MS_Col3Desc',  @value = '[Descripcion de 
la columna 3]',  @level0type = N'Schema', @level0name = '[schema_name]',  
@level1type = N'Table',  @level1name = '[table_name]',  @level2type = N'Column', 
@level2name = '[column3_name]';
usuarioCreaID INT
fechaCreacion date
usuarioModificaID INT
fechaModificacion date
-- 
********************************************************************************
***************

2. Las modificaciones realizadas sobre los triggers, los procedimientos almacenados y 
funciones deben ser identificables, por tanto deben tener la siguiente nomenclatura.
-- Cliente          : < Nombre del Cliente >
-- Sistema          : < Nombre del sistema > 
-- MÃ³dulo           : < Nombre del MÃ³dulo del Sistema >
-- Autor            : < Nombre del autor / desarrollador >
-- Nombre Objeto    : < Nombre del trigger/funcion/store procedure >
-- Fecha Creacion   : < Fecha Creacion dd/mm/yyyy >
-- ------------------------------------------------------------------------------
-----------------
-- Descripcion      : < Describe el propÃ³sito del objeto a nivel funcional. Si 
es necesario, 
-- describe el diseÃ±o del objeto a muy alto nivel. >
-- 
--
-- Input Parameters: < Describe cada uno de los parÃ¡metros de entrada del objeto. 
>
--
-- Output Parameters: < Describe  cada uno de los parÃ¡metros de salida del 
objeto. >
--
-- Input/Output Parameters: < Describe cada uno de los parÃ¡metros de 
entrada/salida del objeto. >
-- 
-- ------------------------------------------------------------------------------
-----------------
-- -- Revisiones
-- ------------------------------------------------------------------------------
-----------------
-- -- Modificacion      : < MOD_XXXX >
-- -- Modificado por    : < Nombre de quien modifica >
-- -- Fecha Modificacion: < Fecha de modificacion >
-- -- Motivo Cambio     : < Descripcion del motivo de cambio >
-- ------------------------------------------------------------------------------
-----------------
-- -- Modificacion      : < MOD_0002 >
-- -- Modificado por    :
-- -- Fecha Modificacion:
-- -- Motivo Cambio     :
-- ------------------------------------------------------------------------------
-----------------
-- 
********************************************************************************
***************
-- <INI - MOD_XXXX >
-- LÃ­neas de cÃ³digo
-- ....
-- ..
-- .
-- <FIN - MOD_XXXX >

Vistas
 
1. Todas las vistas deben contener el siguiente encabezado y en la parte revisiones se debe 
iterar segÃºn los cambios realizados:
2. Las modificaciones realizadas sobre las vistas deben ser identificables, por tanto deben 
tener la siguiente nomenclatura.
Â 
DefiniciÃ³n de scripts
 
1. La extensiÃ³n de los archivos y scripts para bases de datos debe ser .sql
2. Los objetos nuevos solo deben tener la sentencia CREATE, en caso que sea modificado 
reciÃ©n colocar CREATE OR REPLACE.
3. Los nombres de los scripts deben tener la siguiente nomenclatura: enumeraciÃ³n por orden 
de ejecuciÃ³n, numero de proyecto, nombre del script (sin espacios en blanco) y la extensiÃ³n.
-- 
********************************************************************************
***************
-- Cliente          : < Nombre del Cliente >
-- Sistema          : < Nombre del sistema > 
-- MÃ³dulo           : < Nombre del MÃ³dulo del Sistema >
-- Autor            : < Nombre del autor / desarrollador >
-- Nombre Objeto    : < Nombre del trigger/funcion/store procedure >
-- Fecha Creacion   : < Fecha Creacion dd/mm/yyyy >
-- ------------------------------------------------------------------------------
-----------------
-- Descripcion      : < Describe el propÃ³sito del objeto a nivel funcional. Si 
es necesario, 
-- describe el diseÃ±o del objeto a muy alto nivel. >
-- 
-- ------------------------------------------------------------------------------
-----------------
-- -- Revisiones
-- ------------------------------------------------------------------------------
-----------------
-- -- Modificacion      : < MOD_XXXX >
-- -- Modificado por    : < Nombre de quien modifica >
-- -- Fecha Modificacion: < Fecha de modificacion >
-- -- Motivo Cambio     : < Descripcion del motivo de cambio >
-- ------------------------------------------------------------------------------
-----------------
-- 
********************************************************************************
***************
-- <INI - MOD_XXXX >
-- LÃ­neas de cÃ³digo
-- ....
-- ..
-- .
-- <FIN - MOD_XXXX >

4. La sintaxis de los archivos de las sentencias mÃºltiples de DML deben terminar en punto y 
coma â€˜;â€™.
Â 
Ejemplo
 
Tabla y PK
 
CREATE TABLE planta.productoEtiquetadoPlanta (
 Â   ProductoEtiquetadoPlantaID INT IDENTITY(1,1),
 Â   finalProductID Â  Â  Â  Â  INT NOT NULL, Â  Â  Â  Â  -- 
packing.finalproducts.finalProductID
 Â   campaignID Â  Â  Â  Â  Â  Â  INT NOT NULL, Â  Â  Â  Â  -- grower.campaign.campaignID
 Â   packingID Â  Â  Â  Â  Â  Â  Â INT NOT NULL, Â  Â  Â  Â  -- packing.packings.packingID
 Â   gtin Â  Â  Â  Â  Â  Â  Â  Â  Â  VARCHAR(50) NULL, Â  Â  -- CÃ³digo GTIN
 Â   ean13 Â  Â  Â  Â  Â  Â  Â  Â  Â VARCHAR(13) NULL, Â  Â  -- CÃ³digo EAN13
 Â   upc Â  Â  Â  Â  Â  Â  Â  Â  Â  Â VARCHAR(12) NULL, Â  Â  -- CÃ³digo UPC
 Â   code11 Â  Â  Â  Â  Â  Â  Â  Â  VARCHAR(50) NULL, Â  Â  -- CÃ³digo GS1 (renombrado como 
code11)
 Â   estado Â  Â  Â  Â  Â  Â  Â  Â  BIT NOT NULL DEFAULT 1, -- 0: Anulado, 1: Activo
 Â   usuarioCreaID Â  Â  Â  Â  Â INT NOT NULL,
 Â   fechaCreacion Â  Â  Â  Â  Â DATETIME NOT NULL DEFAULT GETDATE(),
 Â   usuarioModificaID Â  Â  Â INT NULL,
 Â   fechaModificacion Â  Â  Â DATETIME NULL
);
-- Primary Key
ALTER TABLE planta.productoEtiquetadoPlanta ADD CONSTRAINT 
PK_productoEtiquetadoPlanta PRIMARY KEY (idProductoEtiquetadoPlanta);
GO
-- Descripciones extendidas
-- La tabla
EXEC sp_addextendedproperty @name = N'MS_TablaDescription', @value = N'Tabla 
local para configuraciÃ³n de productos etiquetados por planta y campaÃ±a', 
@level0type = N'SCHEMA', @level0name = 'planta', @level1type = N'TABLE', 
@level1name = 'productoEtiquetadoPlanta';
-- Las columnas
EXEC sp_addextendedproperty @name = N'MS_Col1Desc', @value = 'Identificador 
Ãºnico de la tabla', @level0type = N'Schema', @level0name = 'planta',@level1type 
= N'Table', @level1name = 'productoEtiquetadoPlanta', @level2type = N'Column', 
@level2name = 'ProductoEtiquetadoPlantaID';
EXEC sp_addextendedproperty @name = N'MS_Col2Desc', @value = 'Identificador del 
producto final', @level0type = N'Schema', @level0name = 'planta',@level1type = 
N'Table', @level1name = 'productoEtiquetadoPlanta', @level2type = N'Column', 
@level2name = 'finalProductID';
EXEC sp_addextendedproperty @name = N'MS_Col3Desc', @value = 'Identificador de 
la campaÃ±a', @level0type = N'Schema', @level0name = 'planta',@level1type = 
N'Table', @level1name = 'productoEtiquetadoPlanta', @level2type = N'Column', 
@level2name = 'campaignID';
EXEC sp_addextendedproperty @name = N'MS_Col4Desc', @value = 'Identificador del 
packing', @level0type = N'Schema', @level0name = 'planta',@level1type = 
N'Table', @level1name = 'productoEtiquetadoPlanta', @level2type = N'Column', 
@level2name = 'packingID';

Constraint
 
Foreing Key
 
EXEC sp_addextendedproperty @name = N'MS_Col5Desc', @value = 'CÃ³digo de barras 
GTIN', @level0type = N'Schema', @level0name = 'planta',@level1type = N'Table', 
@level1name = 'productoEtiquetadoPlanta', @level2type = N'Column', @level2name = 
'gtin';
EXEC sp_addextendedproperty @name = N'MS_Col6Desc', @value = 'CÃ³digo de barras 
EAN13', @level0type = N'Schema', @level0name = 'planta',@level1type = N'Table', 
@level1name = 'productoEtiquetadoPlanta', @level2type = N'Column', @level2name = 
'ean13';
EXEC sp_addextendedproperty @name = N'MS_Col7Desc', @value = 'CÃ³digo de barras 
UPC', @level0type = N'Schema', @level0name = 'planta',@level1type = N'Table', 
@level1name = 'productoEtiquetadoPlanta', @level2type = N'Column', @level2name = 
'upc';
EXEC sp_addextendedproperty @name = N'MS_Col8Desc', @value = 'CÃ³digo de barras 
GS1 (Code11)', @level0type = N'Schema', @level0name = 'planta',@level1type = 
N'Table', @level1name = 'productoEtiquetadoPlanta', @level2type = N'Column', 
@level2name = 'code11';
EXEC sp_addextendedproperty @name = N'MS_Col9Desc', @value = 'Estado del 
registro (0: Anulado, 1: Activo)', @level0type = N'Schema', @level0name = 
'planta',@level1type = N'Table', @level1name = 'productoEtiquetadoPlanta', 
@level2type = N'Column', @level2name = 'estado';
EXEC sp_addextendedproperty @name = N'MS_Col10Desc', @value = 'Usuario creador 
del registro', @level0type = N'Schema', @level0name = 'planta',@level1type = 
N'Table', @level1name = 'productoEtiquetadoPlanta', @level2type = N'Column', 
@level2name = 'usuarioCreaID';
EXEC sp_addextendedproperty @name = N'MS_Col11Desc', @value = 'Fecha de creacion 
del registro', @level0type = N'Schema', @level0name = 'planta',@level1type = 
N'Table', @level1name = 'productoEtiquetadoPlanta', @level2type = N'Column', 
@level2name = 'fechaCreacion';
EXEC sp_addextendedproperty @name = N'MS_Col12Desc', @value = 'Usuario que 
actualizÃ³ por ultima vez', @level0type = N'Schema', @level0name = 
'planta',@level1type = N'Table', @level1name = 'productoEtiquetadoPlanta', 
@level2type = N'Column', @level2name = 'usuarioModificaID';
EXEC sp_addextendedproperty @name = N'MS_Col13Desc', @value = 'Fecha de ultima 
actualizacion', @level0type = N'Schema', @level0name = 'planta',@level1type = 
N'Table', @level1name = 'productoEtiquetadoPlanta', @level2type = N'Column', 
@level2name = 'fechaModificacion';
GO
ALTER TABLE planta.productoEtiquetadoPlanta ADD CONSTRAINT 
CK_productoEtiquetadoPlanta_estadoID_01 CHECK (estado IN (0,1));
ALTER TABLE planta.productoEtiquetadoPlanta ADD CONSTRAINT 
FK_productoEtiquetadoPlanta_FinalProduct_01
 Â   FOREIGN KEY (finalProductID) REFERENCES 
packing.finalproducts(finalProductID);
ALTER TABLE planta.productoEtiquetadoPlanta ADD CONSTRAINT 
FK_productoEtiquetadoPlanta_Campaign_02
 Â   FOREIGN KEY (campaignID) REFERENCES grower.campaign(campaignID);

Indice
 
Procedimiento Almacenado
 
1. Ejemplo cuando se crea un procedimiento almacenado
CREATE INDEX IDX_productoEtiquetadoPlanta_finalProductID_001
ON planta.productoEtiquetadoPlanta (finalProductID);
CREATE PROCEDURE [planta].[usp_productoEtiquetadoPlanta_ins]
(
    @pIn_finalProductID INT,
 Â   @pIn_campaignID     INT,
 Â   @pIn_packingID      INT,
 Â   @pOu_mensajeID      INT OUTPUT,
 Â   @pOu_mensaje        VARCHAR(200) OUTPUT
)
AS
-- 
********************************************************************************
***************
-- Cliente          : < Migiva >
-- Sistema          : < Sispacking > 
-- MÃ³dulo           : < Nombre del MÃ³dulo del Sistema >
-- Autor            : < Christian Villaverde >
-- Nombre Objeto    : < planta.sp_productoEtiquetadoPlanta >
-- Fecha Creacion   : < 03/10/2025 >
-- ------------------------------------------------------------------------------
-----------------
-- Descripcion      : < SP para registrar en la tabla 
planta.productoEtiquetadoPlanta >
-- Â 
-- 
-- Input Parameters: < Describe cada uno de los parÃ¡metros de entrada del objeto. 
>
-- @pIn_campaignID      Parametro de campaÃ±a    
-- @pIn_packingID       Parametro de packing    
--
-- Output Parameters: < Describe  cada uno de los parÃ¡metros de salida del 
objeto. >
-- @pOu_mensajeID       Codigo/Id de mensaje retornado al usuario
-- @pOu_mensaje         Mensaje retornado al usuario
--
-- Input/Output Parameters: < Describe cada uno de los parÃ¡metros de 
entrada/salida del objeto. >
-- 
--
-- ------------------------------------------------------------------------------
-----------------
-- -- Revisiones
-- ------------------------------------------------------------------------------
-----------------
-- -- Modificacion      : < MOD_XXXX >
-- -- Modificado por    : < Nombre de quien modifica >
-- -- Fecha Modificacion: < Fecha de modificacion >
-- -- Motivo Cambio     : < Descripcion del motivo de cambio >

-- ------------------------------------------------------------------------------
-----------------
-- 
********************************************************************************
***************
BEGIN
 Â  Â SET NOCOUNT ON; 
 Â  Â SET ARITHABORT ON;
 Â  Â SET ANSI_NULLS ON;
 Â  Â SET XACT_ABORT ON;
    BEGIN TRY
        BEGIN TRANSACTION Insertar
 Â  Â  Â  Â -- Validar que la campaÃ±a exista
 Â  Â  Â   IF NOT EXISTS (SELECT 1 FROM grower.campaign WHERE campaignID = 
@pIn_campaignID)
 Â  Â  Â  Â BEGIN
 Â  Â  Â  Â  Â  Â SET @pOu_mensajeID  = 2;
 Â  Â  Â  Â  Â  Â SET @pOu_mensaje    = N'âŒ La campaÃ±a especificada no existe.';
 Â  Â  Â  Â  Â   RETURN;
 Â  Â  Â   END
 Â  Â  Â  Â -- Validar que existe el packing
 Â  Â  Â   IF NOT EXISTS (SELECT 1 FROM packing.packings WHERE packingID = 
@pIn_packingID AND statusID = 1)
 Â  Â  Â  Â BEGIN
 Â  Â  Â  Â  Â  Â SET @pOu_mensajeID  = 2;
 Â  Â  Â  Â  Â  Â SET @pOu_mensaje    = N'âŒ El packing especificado no existe.';
 Â  Â  Â  Â  Â   RETURN;
 Â  Â  Â   END
        
 Â  Â  Â  Â INSERT INTO planta.productoEtiquetadoPlanta (
 Â  Â  Â  Â  Â   finalProductID, 
 Â  Â  Â  Â  Â   campaignID, 
 Â  Â  Â  Â  Â   packingID,
 Â  Â  Â  Â  Â   estado, 
 Â  Â  Â  Â  Â   usuarioCreaID, 
 Â  Â  Â  Â  Â   fechaCreacion, 
 Â  Â  Â  Â  Â   usuarioModifcaID, 
 Â  Â  Â  Â  Â   fechaModificacion
 Â  Â  Â   ) VALUES (
 Â  Â  Â  Â  Â   @pIn_finalProductID, 
 Â  Â  Â  Â  Â   @pIn_campaignID, 
 Â  Â  Â  Â  Â   @pIn_packingID,
 Â  Â  Â  Â  Â  Â 1, 
 Â  Â  Â  Â  Â  Â 12, 
 Â  Â  Â  Â  Â   GETDATE(), 
 Â  Â  Â  Â  Â  Â 12, 
 Â  Â  Â  Â  Â   GETDATE()
 Â  Â  Â   );
        COMMIT TRAN Insertar
 Â  Â  Â  Â SET @pOu_mensajeID  = 1;
 Â  Â  Â  Â SET @pOu_mensaje    = N'âœ… ConfiguraciÃ³n de cÃ³digos de barras creada 
correctamente.';
 Â   END TRY
 Â  Â BEGIN CATCH
 Â       IF @@TRANCOUNT > 0

2. Ejemplo cuando se modifica un procedimiento almacenado
 Â           ROLLBACK TRANSACTION Insertar
 Â           
 Â  Â  Â  Â SET @pOu_mensajeID  = 0;
 Â  Â  Â  Â SET @pOu_mensaje    = N'ğŸš« Error al insertar: ' + ERROR_MESSAGE();
 Â   END CATCH
END
CREATE OR ALTER PROCEDURE [planta].[usp_productoEtiquetadoPlanta_ins]
(
    @pIn_finalProductID INT,
 Â   @pIn_campaignID     INT,
 Â   @pIn_packingID      INT,
 Â   @pOu_mensajeID      INT OUTPUT,
 Â   @pOu_mensaje        VARCHAR(200) OUTPUT
)
AS
-- 
********************************************************************************
***************
-- Cliente          : < Migiva >
-- Sistema          : < Sispacking > 
-- MÃ³dulo           : < Nombre del MÃ³dulo del Sistema >
-- Autor            : < Christian Villaverde >
-- Nombre Objeto    : < planta.sp_productoEtiquetadoPlanta >
-- Fecha Creacion   : < 03/10/2025 >
-- ------------------------------------------------------------------------------
-----------------
-- Descripcion      : < SP para registrar en la tabla 
planta.productoEtiquetadoPlanta >
-- Â 
-- 
-- Input Parameters: < Describe cada uno de los parÃ¡metros de entrada del objeto. 
>
-- @pIn_finalProductID  Parametro de finalProduct
-- @pIn_campaignID      Parametro de campaÃ±a    
-- @pIn_packingID       Parametro de packing    
--
-- Output Parameters: < Describe  cada uno de los parÃ¡metros de salida del 
objeto. >
-- @pOu_mensajeID       Codigo/Id de mensaje retornado al usuario
-- @pOu_mensaje         Mensaje retornado al usuario
--
-- Input/Output Parameters: < Describe cada uno de los parÃ¡metros de 
entrada/salida del objeto. >
-- 
--
-- ------------------------------------------------------------------------------
-----------------
-- -- Revisiones
-- ------------------------------------------------------------------------------
-----------------
-- -- Modificacion      : < MOD_0001 >
-- -- Modificado por    : < Anders Romero >
-- -- Fecha Modificacion: < 05/10/2025 >
-- -- Motivo Cambio     : < Validar si existen duplicados >

-- ------------------------------------------------------------------------------
-----------------
-- -- Modificacion      : < MOD_0002 >
-- -- Modificado por    : < Christian Villaverde >
-- -- Fecha Modificacion: < 08/10/2025 >
-- -- Motivo Cambio     : < Validar si campaÃ±a esta activa >
-- ------------------------------------------------------------------------------
-----------------
-- -- Modificacion      : < MOD_0003 >
-- -- Modificado por    : < Christian Villaverde >
-- -- Fecha Modificacion: < 09/10/2025 >
-- -- Motivo Cambio     : < Cambiar RETURN por THROW wn la validacion packing >
-- ------------------------------------------------------------------------------
-----------------
-- 
********************************************************************************
***************
BEGIN
 Â  Â SET NOCOUNT ON; 
 Â  Â SET ARITHABORT ON;
 Â  Â SET ANSI_NULLS ON;
 Â  Â SET XACT_ABORT ON;
    BEGIN TRY
        BEGIN TRANSACTION Insertar
 Â  Â  Â  Â -- Validar que la campaÃ±a exista
 Â  Â  Â  Â -- <INI - MOD_0002 >
 Â  Â  Â  Â -- IF NOT EXISTS (SELECT 1 FROM grower.campaign WHERE campaignID = 
@pIn_campaignID)
 Â  Â  Â   IF NOT EXISTS (SELECT 1 FROM grower.campaign WHERE campaignID = 
@pIn_campaignID AND statusID = 1)
 Â  Â  Â  Â -- <FIN - MOD_0002 >
 Â  Â  Â  Â BEGIN
 Â  Â  Â  Â  Â  Â SET @pOu_mensajeID  = 2;
 Â  Â  Â  Â  Â  Â SET @pOu_mensaje    = N'âŒ La campaÃ±a especificada no existe.';
 Â  Â  Â  Â  Â   RETURN;
 Â  Â  Â   END
 Â  Â  Â  Â -- Validar que existe el packing
 Â  Â  Â   IF NOT EXISTS (SELECT 1 FROM packing.packings WHERE packingID = 
@pIn_packingID AND statusID = 1)
 Â  Â  Â  Â BEGIN
 Â  Â  Â  Â  Â  Â SET @pOu_mensajeID  = 2;
 Â  Â  Â  Â  Â  Â SET @pOu_mensaje    = N'âŒ El packing especificado no existe.';
 Â  Â  Â  Â  Â  Â -- <INI - MOD_0003 >
 Â  Â  Â  Â  Â  Â -- RETURN;
 Â  Â  Â  Â  Â   THROW @pOu_mensajeID, @pOu_mensaje, 1;
 Â  Â  Â  Â  Â  Â -- <FIN - MOD_0003 >
 Â  Â  Â   END
        -- <INI - MOD_0001 >
        -- Validar duplicados activos
 Â  Â  Â   IF EXISTS (
 Â  Â  Â  Â  Â  Â SELECT 1 FROM planta.productoEtiquetadoPlanta
 Â  Â  Â  Â  Â  Â WHERE finalProductID = @pIn_finalProductID
 Â  Â  Â  Â  Â  Â  Â AND campaignID = @pIn_campaignID
 Â  Â  Â  Â  Â  Â  Â AND packingID = @pIn_packingID
 Â  Â  Â  Â  Â  Â  Â AND estado = 1

Funcion
 
Funcion Escalar
 
 Â  Â  Â   )
 Â  Â  Â  Â BEGIN
 Â  Â  Â  Â  Â  Â SET @pOu_mensajeID  = 2;
 Â  Â  Â  Â  Â  Â SET @pOu_mensaje    = N'âŒ Ya existe una configuraciÃ³n activa para 
este producto en esta campaÃ±a y packing.';
 Â  Â  Â  Â  Â   RETURN;
 Â  Â  Â   END
 Â  Â  Â  Â -- <FIN - MOD_0001 >
        
 Â  Â  Â  Â INSERT INTO planta.productoEtiquetadoPlanta (
 Â  Â  Â  Â  Â   finalProductID, 
 Â  Â  Â  Â  Â   campaignID, 
 Â  Â  Â  Â  Â   packingID,
 Â  Â  Â  Â  Â   estado, 
 Â  Â  Â  Â  Â   usuarioCreaID, 
 Â  Â  Â  Â  Â   fechaCreacion, 
 Â  Â  Â  Â  Â   usuarioModifcaID, 
 Â  Â  Â  Â  Â   fechaModificacion
 Â  Â  Â   ) VALUES (
 Â  Â  Â  Â  Â   @pIn_finalProductID, 
 Â  Â  Â  Â  Â   @pIn_campaignID, 
 Â  Â  Â  Â  Â   @pIn_packingID,
 Â  Â  Â  Â  Â  Â 1, 
 Â  Â  Â  Â  Â  Â 12, 
 Â  Â  Â  Â  Â   GETDATE(), 
 Â  Â  Â  Â  Â  Â 12, 
 Â  Â  Â  Â  Â   GETDATE()
 Â  Â  Â   );
 Â  Â  Â   COMMIT TRAN Insertar
 Â  Â  Â  Â SET @pOu_mensajeID  = 1;
 Â  Â  Â  Â SET @pOu_mensaje    = N'âœ… ConfiguraciÃ³n de cÃ³digos de barras creada 
correctamente.';
 Â   END TRY
 Â  Â BEGIN CATCH
 Â       IF @@TRANCOUNT > 0
 Â           ROLLBACK TRANSACTION Insertar
 Â           
 Â  Â  Â  Â SET @pOu_mensajeID  = 0;
 Â  Â  Â  Â SET @pOu_mensaje    = N'ğŸš« Error al insertar: ' + ERROR_MESSAGE();
 Â  Â  Â  Â -- <INI - MOD_0003 >
 Â  Â  Â   THROW @pOu_mensajeID, @pOu_mensaje, ERROR_STATE();
 Â  Â  Â  Â -- <FIN - MOD_0003 >
 Â   END CATCH
END
CREATE FUNCTION [agroamigo].[ufn_sistemas_obtenerFecha]()
RETURNS DATETIME
AS
-- 
********************************************************************************
***************

Funcion Tabla
 
-- Cliente          : < Migiva >
-- Sistema          : < Todos los sitemas > 
-- MÃ³dulo           : < Todos los mÃ³dulos >
-- Autor            : < Christian Villaverde >
-- Nombre Objeto    : < agroamigo.ufn_sistemas_obtenerFecha >
-- Fecha Creacion   : < 03/10/2025 >
-- ------------------------------------------------------------------------------
-----------------
-- Descripcion      : < FunciÃ³n que devuelve la fecha en el formato UTC - 5 >
-- Â 
-- 
-- Input Parameters: < No presenta. >
--
-- Output Parameters: < No presenta. >
--
-- Input/Output Parameters: < No presenta. >
-- 
--
-- ------------------------------------------------------------------------------
-----------------
-- -- Revisiones
-- ------------------------------------------------------------------------------
-----------------
-- -- Modificacion      : < MOD_XXXX >
-- -- Modificado por    : < Nombre de quien modifica >
-- -- Fecha Modificacion: < Fecha de modificacion >
-- -- Motivo Cambio     : < Descripcion del motivo de cambio >
-- ------------------------------------------------------------------------------
-----------------
-- 
********************************************************************************
***************
BEGIN
    DECLARE @vFecha AS DATETIMEOFFSET
    SET @vFecha = CONVERT(DATETIMEOFFSET, GETDATE()) AT TIME ZONE 'SA Pacific 
Standard Time'
    RETURN CONVERT(DATETIME, @vFecha);
END
GO
CREATE FUNCTION [planta].[uft_obtenerOnpremID](
 Â   @pIn_onpremID INT
)
RETURNS TABLE
AS
-- 
********************************************************************************
***************
-- Cliente          : < Migiva >
-- Sistema          : < Todos los sitemas > 
-- MÃ³dulo           : < Todos los mÃ³dulos >
-- Autor            : < Christian Villaverde >
-- Nombre Objeto    : < planta.uft_obtenerOnpremID >
-- Fecha Creacion   : < 03/10/2025 >

Vista
 
-- ------------------------------------------------------------------------------
-----------------
-- Descripcion      : < FunciÃ³n que devuelve el packing a quien pertenece el 
on_premID >
-- Â 
-- 
-- Input Parameters: <  >
-- @pIn_onpremID    ParÃ¡metro de Id del  on_premID a visualizar
-- 
-- Output Parameters: < No presenta. >
--
-- Input/Output Parameters: < No presenta. >
-- 
--
-- ------------------------------------------------------------------------------
-----------------
-- -- Revisiones
-- ------------------------------------------------------------------------------
-----------------
-- -- Modificacion      : < MOD_XXXX >
-- -- Modificado por    : < Nombre de quien modifica >
-- -- Fecha Modificacion: < Fecha de modificacion >
-- -- Motivo Cambio     : < Descripcion del motivo de cambio >
-- ------------------------------------------------------------------------------
-----------------
-- 
********************************************************************************
***************
RETURN
    SELECT 
        on_premID, 
 Â  Â  Â   CASE 
 Â  Â  Â  Â  Â   WHEN on_premID = 1 THEN 'CAL' 
 Â  Â  Â  Â  Â   WHEN on_premID = 2 THEN 'NAT' 
 Â  Â  Â  Â  Â   WHEN on_premID = 3 THEN 'CAR' 
 Â  Â  Â  Â  Â   WHEN on_premID = 4 THEN 'BMP' 
 Â  Â  Â   ELSE 
 Â  Â  Â       '' 
 Â  Â  Â   END AS farmID 
    FROM 
        packing.on_prem 
    WHERE 
        on_premID = @pIn_onpremID
GO
CREATE VIEW [Maestra].[vwc_Maestra_obtenerDatosPersona] 
as
-- 
********************************************************************************
***************
-- Cliente          : < Migiva >
-- Sistema          : < Todos los sitemas > 
-- MÃ³dulo           : < Todos los mÃ³dulos >
-- Autor            : < Christian Villaverde >

Â 
Base de Datos de Proveedores
 
Estas Bases de Datos no estÃ¡n sujetas completamente a los estÃ¡ndares de codificaciÃ³n, pero 
deben cumplir lo mÃ­nimo requerido por TI para su entrega en ProducciÃ³n. (Ver Documento 
Asociado "Entrega de Base de Datos a ProducciÃ³n")
AsÃ­ mismo se debe tener en cuenta lo siguiente:
Los nuevos objetos creados (desarrollo interno) que explotan la data de en una Base de 
Datos de proveedores deben ir en un esquema nuevo cumpliendo los estÃ¡ndares.
No se debe contar con el rol DBA en los esquemas.
Contar con un usuarios de conexiÃ³n para no acceder directamente al core de la Base de 
Datos.
Â 
Buenas PrÃ¡cticas de Base de Datos T-SQL
 
-- Nombre Objeto    : < Maestra.vwc_Maestra_obtenerDatosPersona >
-- Fecha Creacion   : < 03/10/2025 >
-- ------------------------------------------------------------------------------
-----------------
-- Descripcion      : < Vista para devolver el listado de personas >
-- Â 
-- 
-- ------------------------------------------------------------------------------
-----------------
-- -- Revisiones
-- ------------------------------------------------------------------------------
-----------------
-- -- Modificacion      : < MOD_XXXX >
-- -- Modificado por    : < Nombre de quien modifica >
-- -- Fecha Modificacion: < Fecha de modificacion >
-- -- Motivo Cambio     : < Descripcion del motivo de cambio >
-- ------------------------------------------------------------------------------
-----------------
-- 
********************************************************************************
***************
select 
 Â   p.Id,LTRIM(RTRIM(CONCAT(P.ApellidoPaterno,' ',P.ApellidoMaterno,' 
',p.Nombres))) Nombre, 
 Â   t.Abreviatura TipoDocumento,
 Â   p.NumeroDocumento,
 Â   p.Direccion,
 Â   p.Correo,
 Â   p.Abreviatura,
 Â   p.growerId
from 
    [Maestra].[PersonaEntidad]  p
    inner join [Maestra].[TipoDocumento] t on t.Id = p.IdTipoDocumento
where 
    p.Estado=1
GO

Consultas T-SQL
 
1. Evitar usar SELECT *
Siempre especifica las columnas que realmente necesitas en lugar de usar SELECT * , para 
reducir E/S, mejorar rendimiento y evitar problemas ante cambios de esquema.
Mal Ejemplo âŒ
Buen Ejemplo âœ…
Â 
2. Evita funciones en columnas dentro de filtros WHERE  
No utilices funciones sobre columnas en condiciones de bÃºsqueda, ya que invalidan el uso 
de Ã­ndices y degradan el rendimiento.
Mal Ejemplo âŒ
Buen Ejemplo âœ…
Â 
3. Usa JOIN  explÃ­citos en lugar de WHERE  para unir tablas
Los JOIN  explÃ­citos son mÃ¡s legibles, evitan errores lÃ³gicos y son el estÃ¡ndar moderno de 
SQL.
Mal Ejemplo âŒ
Buen Ejemplo âœ…
Â 
4. Evita cursores cuando puedas usar operaciones en conjunto
Los cursores son costosos. Prefiere operaciones basadas en conjuntos ( UPDATE , INSERT , 
MERGE , CTE , etc.).
SELECT * FROM Sales.Orders;
SELECT OrderID, CustomerID, OrderDate, TotalAmount
FROM Sales.Orders;
SELECT * FROM Sales.Orders
WHERE YEAR(OrderDate) = 2025;
SELECT * FROM Sales.Orders
WHERE OrderDate >= '2025-01-01' AND OrderDate < '2026-01-01';
SELECT o.OrderID, c.CustomerName
FROM Sales.Orders o, Sales.Customers c
WHERE o.CustomerID = c.CustomerID;
SELECT o.OrderID, c.CustomerName
FROM Sales.Orders AS o
INNER JOIN Sales.Customers AS c ON o.CustomerID = c.CustomerID;

Mal Ejemplo âŒ
Buen Ejemplo âœ…
Â 
5. Utiliza EXISTS  en lugar de COUNT(*)  para validaciones
Cuando solo se necesita verificar si existen registros, EXISTS  es mÃ¡s eficiente que 
COUNT(*) .
Mal Ejemplo âŒ
Buen Ejemplo âœ…
Â 
6. Declara variables con tipos de datos apropiados
Usar tipos de datos incorrectos genera conversiones implÃ­citas y afecta el rendimiento.
Mal Ejemplo âŒ
Buen Ejemplo âœ…
DECLARE order_cursor CURSOR FOR
SELECT OrderID FROM Sales.Orders;
OPEN order_cursor;
FETCH NEXT FROM order_cursor INTO @OrderID;
WHILE @@FETCH_STATUS = 0
BEGIN
 Â  Â UPDATE Sales.Orders SET Status = 'Closed' WHERE OrderID = @OrderID;
 Â   FETCH NEXT FROM order_cursor INTO @OrderID;
END
CLOSE order_cursor;
DEALLOCATE order_cursor;
UPDATE Sales.Orders
SET Status = 'Closed'
WHERE Status = 'Open';
IF (SELECT COUNT(*) FROM Sales.Orders WHERE CustomerID = @CustomerID) > 0
 Â   PRINT 'Tiene pedidos';
IF EXISTS (SELECT 1 FROM Sales.Orders WHERE CustomerID = @CustomerID)
 Â   PRINT 'Tiene pedidos';
DECLARE @CustomerID NVARCHAR(50) = '100';
SELECT * FROM Sales.Orders WHERE CustomerID = @CustomerID;
DECLARE @CustomerID INT = 100;
SELECT * FROM Sales.Orders WHERE CustomerID = @CustomerID;

Â 
7. Evita usar DISTINCT  para corregir duplicados
Usa DISTINCT  solo cuando sea realmente necesario. Analiza y corrige la causa de los 
duplicados desde el origen o la uniÃ³n.
Mal Ejemplo âŒ
Buen Ejemplo âœ…
Â 
8. Evita subconsultas anidadas cuando puedes usar JOIN  o APPLY
Las subconsultas correlacionadas suelen ser mÃ¡s lentas. Prefiere JOIN  o CROSS APPLY  para 
optimizar.
Mal Ejemplo âŒ
Buen Ejemplo âœ…
Uso de Ãndices
 
1. Crear Ã­ndices solo donde aporten valor
Crea Ã­ndices basados en las consultas mÃ¡s frecuentes y costosas (lecturas, joins, filtros o 
agrupaciones).
 Evita crear Ã­ndices innecesarios, ya que cada Ã­ndice adicional incrementa el costo de 
escritura (INSERT, UPDATE, DELETE).
Mal Ejemplo âŒ
SELECT DISTINCT c.CustomerName, o.OrderID
FROM Sales.Customers c
JOIN Sales.Orders o ON c.CustomerID = o.CustomerID;
SELECT c.CustomerName, o.OrderID
FROM Sales.Customers c
JOIN Sales.Orders o ON c.CustomerID = o.CustomerID;
-- Asegurar integridad y claves Ãºnicas correctamente definidas
SELECT c.CustomerName,
 Â  Â  Â  (SELECT COUNT(*) FROM Sales.Orders o WHERE o.CustomerID = 
c.CustomerID) AS TotalOrders
FROM Sales.Customers c;
SELECT c.CustomerName, COUNT(o.OrderID) AS TotalOrders
FROM Sales.Customers c
LEFT JOIN Sales.Orders o ON o.CustomerID = c.CustomerID
GROUP BY c.CustomerName;
-- Ãndices redundantes sin anÃ¡lisis previo
CREATE INDEX IDX_Orders_OrderDate_001 ON Sales.Orders(OrderDate);
CREATE INDEX IDX_Orders_CustomerID_002 ON Sales.Orders(CustomerID);
CREATE INDEX IDX_Orders_CustomerID_OrderDate_003 ON Sales.Orders(CustomerID, 
OrderDate);

Buen Ejemplo âœ…
Â 
2. Colocar las columnas mÃ¡s selectivas primero
En un Ã­ndice compuesto, el orden de las columnas es crÃ­tico. Coloca primero la columna mÃ¡s 
selectiva (la que mÃ¡s reduce el nÃºmero de filas).
Mal Ejemplo âŒ
Buen Ejemplo âœ…
3. Usa Ã­ndices cubrientes (Covering Index)
Un Ã­ndice cubriente incluye todas las columnas que una consulta necesita, evitando lecturas 
adicionales de la tabla (bookmark lookup).
Mejora drÃ¡sticamente el rendimiento de SELECT repetitivos.
Reduce el nÃºmero de lecturas lÃ³gicas.
Buen Ejemplo âœ…
4. Evita Ã­ndices en columnas con alta volatilidad
Columnas que cambian con frecuencia degradan el rendimiento de operaciones DML.
Evita indexar campos como â€œLastUpdatedDateâ€, â€œStatusâ€, o â€œModifiedByâ€ si cambian 
constantemente.
Mal Ejemplo âŒ
Buen Ejemplo âœ…
5. Usa Ã­ndices Ãºnicos donde corresponda
-- Ãndice creado segÃºn patrÃ³n de consulta real
CREATE INDEX IDX_Orders_CustomerID_OrderDate_001
ON Sales.Orders (CustomerID, OrderDate)
INCLUDE (TotalAmount);
CREATE INDEX IDX_Orders_Status_CustomerID_001 ON Sales.Orders(Status, 
CustomerID);
CREATE INDEX IDX_Orders_CustomerID_Status_001 ON Sales.Orders(CustomerID, 
Status);
CREATE INDEX IDX_Orders_CustomerID_OrderDate_001
ON Sales.Orders (CustomerID)
INCLUDE (OrderDate, TotalAmount);
CREATE INDEX IDX_Orders_LastUpdated_001 ON Sales.Orders(LastUpdatedDate);
-- Mejor usar Ã­ndice sobre columnas mÃ¡s estables
CREATE INDEX IDX_Orders_CustomerID_OrderDate_001 ON Sales.Orders(CustomerID, 
OrderDate);

Un Ã­ndice UNIQUE  no solo mejora el rendimiento de bÃºsqueda, sino que garantiza integridad 
lÃ³gica de los datos (Evita duplicidad de datos y reduce necesidad de validaciones adicionales 
en la aplicaciÃ³n.)
Ejemplo âœ…
6. Usa Ã­ndices filtrados ( Filtered Index ) cuando aplique
Los Ã­ndices filtrados son ideales para tablas grandes con pocos valores relevantes (ej: 
registros activos).
Ejemplo âœ…
8. Evita duplicar Ã­ndices (idÃ©nticos o parcialmente iguales)
SQL Server permite crear Ã­ndices redundantes, lo que consume espacio y degrada el 
rendimiento en escritura.
Mal Ejemplo âŒ
Buen Ejemplo âœ…
9. Evita funciones sobre columnas indexadas en WHERE  o JOIN
El uso de funciones anula el Ã­ndice, forzando una lectura completa (table scan).
Mal Ejemplo âŒ
Buen Ejemplo âœ…
10. MantÃ©n consistencia entre Ã­ndices y claves forÃ¡neas
Siempre indexa las columnas utilizadas en relaciones ( FOREIGN KEY ), especialmente en 
tablas hijas (Optimiza joins y validaciones referenciales).
Mal Ejemplo âŒ
CREATE UNIQUE INDEX UK_Customers_Email_001 ON Sales.Customers(Email);
 Â  CREATE INDEX IDX_Orders_ActiveOrders_001
 Â  ON Sales.Orders(OrderDate)
 Â  WHERE Status = 'Open';
CREATE INDEX IDX_Orders_CustomerID_001 ON Sales.Orders(CustomerID);
CREATE INDEX IDX_Orders_CustomerID_OrderDate_002 ON Sales.Orders(CustomerID, 
OrderDate);
-- Deja solo el Ã­ndice mÃ¡s Ãºtil
DROP INDEX IDX_Orders_CustomerID_001 ON Sales.Orders;
SELECT * FROM Sales.Orders
WHERE YEAR(OrderDate) = 2025;
SELECT * FROM Sales.Orders
WHERE OrderDate >= '2025-01-01' AND OrderDate < '2026-01-01';

Buen Ejemplo âœ…
Uso de Tablas Temporales
 
1. Usa tablas temporales solo cuando sea necesario
Las tablas temporales son Ãºtiles para almacenar resultados intermedios, pero si puedes 
resolver el problema con una CTE, subconsulta o table variable simple, evita crearlas.
Ten en cuenta: Crea una tabla temporal solo si se reutiliza varias veces o reduce complejidad 
de joins.
Mal Ejemplo âŒ
Buen Ejemplo âœ…
2. Usa CREATE TABLE  en lugar de SELECT INTO  para control y rendimiento
SELECT INTO  bloquea la compilaciÃ³n y crea metadatos en tempdb  sin control.
 Usar CREATE TABLE  permite definir tipos, Ã­ndices y control total. Algunas ventajas:
Control de tipos de datos
Posibilidad de crear Ã­ndices
Evita recompilaciones innecesarias
Mal Ejemplo âŒ
Buen Ejemplo âœ…
ALTER TABLE Sales.Orders
ADD CONSTRAINT FK_Orders_Customers FOREIGN KEY (CustomerID)
REFERENCES Sales.Customers(CustomerID);
-- Sin Ã­ndice en CustomerID
CREATE INDEX IDX_Orders_CustomerID_001 ON Sales.Orders(CustomerID);
SELECT * INTO #TempOrders FROM Sales.Orders;
SELECT * FROM #TempOrders WHERE OrderDate >= '2025-01-01';
WITH Orders2025 AS (
 Â  Â SELECT OrderID, CustomerID, OrderDate
 Â  Â FROM Sales.Orders
 Â  Â WHERE OrderDate >= '2025-01-01'
)
SELECT OrderID, CustomerID, OrderDate FROM Orders2025;
SELECT * INTO #TempOrders FROM Sales.Orders WHERE OrderDate >= '2025-01-01';

3. Crea Ã­ndices en tablas temporales grandes o reutilizadas
Si la tabla temporal tiene muchos registros o serÃ¡ usada en mÃºltiples joins, podrÃ­as crear 
Ã­ndices para mejorar el rendimiento.
Mal Ejemplo âŒ
Buen Ejemplo âœ…
4. Limpia las tablas temporales al finalizar
Aunque las tablas temporales se eliminan al cerrar la sesiÃ³n, es buena prÃ¡ctica liberarlas 
explÃ­citamente para evitar presiÃ³n sobre tempdb .
Buen Ejemplo âœ…
5. Evita crear/dropear temporales en loops o cursores
Cada ciclo crea/dropea objetos en tempdb , generando fragmentaciÃ³n de metadatos.
Mal Ejemplo âŒ
CREATE TABLE #TempOrders (
 Â   OrderID INT PRIMARY KEY,
 Â   CustomerID INT,
 Â   OrderDate DATE,
 Â   TotalAmount DECIMAL(12,2)
);
INSERT INTO #TempOrders (OrderID, CustomerID, OrderDate, TotalAmount)
SELECT OrderID, CustomerID, OrderDate, TotalAmount
FROM Sales.Orders
WHERE OrderDate >= '2025-01-01';
CREATE TABLE #TempOrders (
 Â   OrderID INT NOT NULL,
 Â   CustomerID INT NOT NULL,
 Â   OrderDate DATE
);
CREATE TABLE #TempOrders (
 Â   OrderID INT NOT NULL,
 Â   CustomerID INT NOT NULL,
 Â   OrderDate DATE,
 Â   INDEX IDX_TempOrders_Customer_001 ID NONCLUSTERED (CustomerID)
);
CREATE TABLE #TempOrders (...);
-- ... operaciones ...
DROP TABLE #TempOrders;
WHILE (@i < 1000)
BEGIN
 Â  Â CREATE TABLE #TempLoop (ID INT);
 Â  Â DROP TABLE #TempLoop;
 Â  Â SET @i += 1;
END

Buen Ejemplo âœ…
6. Usa ##GlobalTemp  solo si es estrictamente necesario
Las tablas temporales globales ( ## ) son visibles por todas las sesiones. Evita su uso salvo en 
procesos coordinados entre sesiones. Recuerda:
Evita ##Temp  en entornos multiusuario o producciÃ³n.
Si debes usarlas, agrega control de nombres (por usuario o proceso).
Mal Ejemplo âŒ
Buen Ejemplo âœ…
Â 
Uso de CTE
 
Una CTE es una expresiÃ³n temporal que existe solo durante la ejecuciÃ³n de una instrucciÃ³n 
SQL.  Se define con WITH NombreCTE AS (...)  y se comporta como una vista temporal.
1. No uses CTE para grandes conjuntos intermedios
La CTE no materializa datos fÃ­sicamente (no se guarda en memoria o disco), asÃ­ que si se 
reusa dentro de la misma consulta, el optimizador puede recalcularla varias veces. 
Recuerda:
Si el mismo resultado se usa muchas veces â†’ Usa una tabla temporal.
Si solo se usa una vez â†’ CTE.
Â 
2. Usa CTE solo para una ejecuciÃ³n
Una CTE no se puede reutilizar dentro de la misma sesiÃ³n o bloque. Si vas a usar el mismo 
conjunto de datos varias veces, usa una tabla temporal ( #Temp ) o variable ( @Table ).
3. Usa CTE para mejorar la legibilidad del cÃ³digo
Las CTE son ideales para dividir una consulta compleja en pasos lÃ³gicos.
CÃ³digo mÃ¡s claro
Ideal para documentar pasos intermedios
Mantenimiento mÃ¡s fÃ¡cil
Mal Ejemplo âŒ
CREATE TABLE #TempLoop (ID INT);
WHILE (@i < 1000)
BEGIN
 Â  Â INSERT INTO #TempLoop VALUES (@i);
 Â  Â SET @i += 1;
END
DROP TABLE #TempLoop;
CREATE TABLE ##TempReport (...);
CREATE TABLE #TempReport (...);

Buen Ejemplo âœ…
4. No abuses de CTE anidados o recursivos
Cada CTE genera una recompilaciÃ³n lÃ³gica. Demasiados anidados pueden degradar el 
rendimiento.
Mal Ejemplo âŒ
Buen Ejemplo âœ…
Â 
Uso de Variables Tabla(@table)
 
Una variable de tabla es una estructura temporal declarada con DECLARE @Nombre TABLE (...) .
Se almacena principalmente en memoria (aunque puede usar tempdb  si crece mucho).
1. Ãšsala solo para conjuntos pequeÃ±os
SELECT c.CustomerID, c.Name, SUM(o.Total) AS TotalSales
FROM Customers c
JOIN Orders o ON c.CustomerID = o.CustomerID
JOIN (
 SELECT CustomerID, COUNT(*) AS NumOrders
 Â  Â FROM Orders
 Â  Â GROUP BY CustomerID
) x ON c.CustomerID = x.CustomerID
WHERE x.NumOrders > 10
GROUP BY c.CustomerID, c.Name;
WITH OrderCount AS (
 Â  Â SELECT CustomerID, COUNT(*) AS NumOrders
 Â  Â FROM Orders
 Â  Â GROUP BY CustomerID
)
SELECT c.CustomerID, c.Name, SUM(o.Total) AS TotalSales
FROM Customers c
JOIN Orders o ON c.CustomerID = o.CustomerID
JOIN OrderCount oc ON c.CustomerID = oc.CustomerID
WHERE oc.NumOrders > 10
GROUP BY c.CustomerID, c.Name;
WITH CTE1 AS (...),
 Â  Â  CTE2 AS (SELECT ... FROM CTE1),
 Â  Â  CTE3 AS (SELECT ... FROM CTE2),
 Â  Â  CTE4 AS (SELECT ... FROM CTE3)
SELECT ... FROM CTE4;
WITH CTE AS (
 Â  Â SELECT ... -- combina la lÃ³gica necesaria
)
SELECT ... FROM CTE;

Las variables de tabla no generan estadÃ­sticas completas. Por eso el optimizador asume 
que solo tienen 1 fila, lo que puede causar malos planes de ejecuciÃ³n. Tener en cuenta o 
como consejo si tiene mas de 1000 filas usemos #Temp
Mal Ejemplo âŒ
Buen Ejemplo âœ…
2. Usa variables de tabla en funciones o procedimientos pequeÃ±os
Las variables de tabla son perfectas para devolver conjuntos en funciones o manejar 
resultados de pequeÃ±a escala.
Ejemplo âœ…
3. No uses @Table en operaciones masivas ni cursores
Si vas a realizar actualizaciones o joins sobre millones de registros, las variables de tabla 
degradan rendimiento (sin paralelismo ni estadÃ­sticas).
Â 
Diferencia CTE, @Table y #Temp
 
DECLARE @Orders TABLE (OrderID INT, Total DECIMAL(10,2));
INSERT INTO @Orders SELECT OrderID, Total FROM Orders; Â -- miles de filas
DECLARE @Orders TABLE (OrderID INT, Total DECIMAL(10,2));
INSERT INTO @Orders SELECT TOP (500) OrderID, Total FROM Orders; -- 
Acortamos los resultados
CREATE FUNCTION dbo.uft_GetTopCustomers()
RETURNS @Result TABLE (
 Â   CustomerID INT,
 Â   Name NVARCHAR(100),
 Â   TotalSales DECIMAL(12,2)
)
AS
BEGIN
 Â  Â INSERT INTO @Result
 Â  Â SELECT TOP (10) CustomerID, Name, SUM(Total)
 Â  Â FROM Sales
 Â  Â GROUP BY CustomerID, Name
 Â  Â ORDER BY SUM(Total) DESC;
 Â   RETURN;
END;

CaracterÃ­stica
CTE
@Table
#Temp
Persistencia
Solo en la
instrucciÃ³n
En la sesiÃ³n
(memoria)
En la sesiÃ³n ( tempdb )
Se almacena
fÃ­sicamente
âŒ No
âš  Parcialmente
âœ… SÃ­
Reutilizable
âŒ No
âœ… SÃ­
âœ… SÃ­
Permite Ã­ndices
âŒ No
âœ… Limitado
âœ… Completo
Genera
estadÃ­sticas
âŒ No
âŒ (hasta SQL
2019)
âœ… SÃ­
Ideal para
Simplificar
consultas
Conjuntos
pequeÃ±os
Conjuntos grandes o
reutilizados
Recomendado en
Lecturas Ãºnicas
Procedimientos
pequeÃ±os
Procedimientos
complejos

